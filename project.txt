### DIRECTORY TREE (excl. __pycache__, .git, .github, .DS_Store, .gitignore, dump_structure.sh, folder_dump_*.txt) ###

.
|   frontend
|   |   index.html
|   |   Dockerfile
|   |   package.json
|   |   tsconfig.json
|   |   vite.config.ts
|   |   src
|   |   |   App.tsx
|   |   |   main.tsx
|   |   |   api.ts
|   |   |   components
|   |   |   |   TarifSettings.tsx
|   |   |   |   FinanceTable.tsx
|   |   |   |   PayrollSettings.tsx
|   backend
|   |   app
|   |   |   auth.py
|   |   |   models.py
|   |   |   database.py
|   |   |   __init__.py
|   |   |   payroll.py
|   |   |   api.py
|   |   |   schemas.py
|   |   |   tarif.py
|   |   |   main.py
|   |   requirements.txt
|   |   Dockerfile
|   |   tests
|   |   |   test_tarif.py
|   |   |   test_payroll.py
|   |   __init__.py
|   README.md
|   docker-compose.yml


### FILE CONTENTS (same exclusions) ###


===== ./frontend/index.html =====

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Finance Suite</title>
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

===== ./frontend/Dockerfile =====

FROM node:20-alpine as build
WORKDIR /app
COPY package.json tsconfig.json vite.config.ts ./
COPY src ./src
COPY index.html ./
RUN npm install && npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

===== ./frontend/package.json =====

{
  "name": "finance-suite-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@chakra-ui/react": "^2.6.1",
    "@chakra-ui/icons": "^2.2.4",
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "framer-motion": "^10.12.16",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^4.12.0",
    "chart.js": "^4.4.1",
    "react-chartjs-2": "^5.2.0"
  },
  "devDependencies": {
    "typescript": "^5.2.2",
    "@types/react": "^18.2.21",
    "@types/react-dom": "^18.2.7",
    "vite": "^4.4.9",
    "@vitejs/plugin-react": "^4.0.3"
  }
}

===== ./frontend/tsconfig.json =====

{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "strict": true,
    "jsx": "react-jsx",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}

===== ./frontend/vite.config.ts =====

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': 'http://backend:8878'
    }
  }
});

===== ./frontend/src/App.tsx =====

import React, { useEffect, useState } from 'react';
import {
  Box,
  Flex,
  IconButton,
  useColorMode,
  useDisclosure,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalCloseButton,
  ModalBody,
  Tabs,
  TabList,
  TabPanels,
  Tab,
  TabPanel,
  Heading,
  VStack
} from '@chakra-ui/react';
import { SunIcon, MoonIcon } from '@chakra-ui/icons';
import {
  FiInfo,
  FiSettings,
  FiRotateCcw,
  FiRotateCw
} from 'react-icons/fi';

import PayrollSettings, {
  PayrollInputUI,
  defaultPayrollInput
} from './components/PayrollSettings';
import TarifSettings, {
  defaultTarifInput,
  TarifInputUI
} from './components/TarifSettings';
import FinanceTable, { FinanceTableHandle } from './components/FinanceTable';
import { loadSettings, saveSettings } from './api';

/* ──────────────────────────────────────────────────────────────────── */
/*  App-level state                                                    */
/* ──────────────────────────────────────────────────────────────────── */
const App: React.FC = () => {
  const { colorMode, toggleColorMode } = useColorMode();
  const settingsDlg = useDisclosure();

  const [year, setYear] = useState<number>(new Date().getFullYear());

  const [tarifInput, setTarifInput] = useState<TarifInputUI>(
    defaultTarifInput
  );
  const [payrollInput, setPayrollInput] = useState<PayrollInputUI>(
    defaultPayrollInput
  );

  /* Load persisted defaults once */
  useEffect(() => {
    loadSettings<TarifInputUI>('tarif').then((s) =>
      setTarifInput({ ...defaultTarifInput, ...s })
    );
    loadSettings<PayrollInputUI>('payroll').then((s) =>
      setPayrollInput({ ...defaultPayrollInput, ...s })
    );
  }, []);

  /* Persist on every change */
  useEffect(() => {
    saveSettings('tarif', tarifInput);
  }, [tarifInput]);
  useEffect(() => {
    saveSettings('payroll', payrollInput);
  }, [payrollInput]);

  /* Expose undo/redo coming from FinanceTable */
  const tableRef = React.useRef<FinanceTableHandle>(null);

  return (
    <Box w="100vw" h="100vh" overflow="hidden">
      {/* ─── Header ─────────────────────────────────────── */}
      <Flex
        as="header"
        w="full"
        h="48px"
        align="center"
        px={2}
        gap={2}
        borderBottom="1px solid"
        borderColor="gray.200"
      >
        <Heading size="sm" flexGrow={1} pl={1}>
          Finance Suite
        </Heading>

        <IconButton
          aria-label="Undo"
          icon={<FiRotateCcw />}
          size="sm"
          variant="ghost"
          onClick={() => tableRef.current?.undo()}
        />
        <IconButton
          aria-label="Redo"
          icon={<FiRotateCw />}
          size="sm"
          variant="ghost"
          onClick={() => tableRef.current?.redo()}
        />

        <IconButton
          aria-label="Toggle colour mode"
          icon={colorMode === 'light' ? <MoonIcon /> : <SunIcon />}
          variant="ghost"
          size="sm"
          onClick={toggleColorMode}
        />
        <IconButton
          aria-label="About"
          icon={<FiInfo />}
          variant="ghost"
          size="sm"
          onClick={() =>
            window.alert('Demo build – IG Metall & German payroll toolkit')
          }
        />
        <IconButton
          aria-label="Settings"
          icon={<FiSettings />}
          variant="ghost"
          size="sm"
          onClick={settingsDlg.onOpen}
        />
      </Flex>

      {/* ─── Full-screen settings modal (non-scrolling) ── */}
      <Modal
        isOpen={settingsDlg.isOpen}
        onClose={settingsDlg.onClose}
        size="full"
        motionPreset="slideInBottom"
      >
        <ModalOverlay />
        <ModalContent maxH="100vh" overflow="hidden">
          <ModalHeader p={3}>Settings</ModalHeader>
          <ModalCloseButton />
          <ModalBody p={4} overflow="auto">
            <Tabs variant="soft-rounded" colorScheme="blue" isFitted>
              <TabList mb={4}>
                <Tab>IG Metall ERA</Tab>
                <Tab>Net Salary</Tab>
              </TabList>
              <TabPanels>
                <TabPanel px={0}>
                  <TarifSettings
                    value={tarifInput}
                    onChange={setTarifInput}
                  />
                </TabPanel>
                <TabPanel px={0}>
                  <PayrollSettings
                    value={payrollInput}
                    onChange={setPayrollInput}
                  />
                </TabPanel>
              </TabPanels>
            </Tabs>
          </ModalBody>
        </ModalContent>
      </Modal>

      {/* ─── Main view ──────────────────────────────────── */}
      <VStack
        spacing={4}
        align="stretch"
        w="full"
        h="calc(100vh - 48px)"
        p={4}
        overflow="hidden"
      >
        <FinanceTable
          ref={tableRef}
          year={year}
          onYearChange={setYear}
          tarifInput={tarifInput}
        />
      </VStack>
    </Box>
  );
};

export default App;

===== ./frontend/src/main.tsx =====

import React from 'react';
import ReactDOM from 'react-dom/client';
import { ChakraProvider, ColorModeScript } from '@chakra-ui/react';
import App from './App';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <ChakraProvider>
      <ColorModeScript initialColorMode="system" />
      <App />
    </ChakraProvider>
  </React.StrictMode>
);

===== ./frontend/src/api.ts =====

/**
 * Centralised fetch helpers used by the React components.
 * Keeps network code in one place and supplies TypeScript
 * types for strong compile-time checks.
 */

export interface Cell {
  year: number;
  row: number;
  col: number;
  value: number;
  revision: number;
}

/* ───────────────────────────────────────────────────────── */
/*  Finance-table persistence                                */
/* ───────────────────────────────────────────────────────── */

export async function getFinance(year: number): Promise<Cell[]> {
  return fetch(/api/finance/${year}).then(r => r.json());
}

export async function saveCell(cell: Cell): Promise<void> {
  await fetch('/api/finance/cell', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(cell)
  });
}

export async function shiftRevision(
  year: number,
  dir: 'undo' | 'redo'
): Promise<number> {
  return fetch(/api/finance/revision/${year}/${dir}, { method: 'POST' }).then(
    r => r.json()
  );
}

/* ───────────────────────────────────────────────────────── */
/*  User-settings persistence                                */
/* ───────────────────────────────────────────────────────── */

export async function loadSettings<T = any>(group: string): Promise<T> {
  return fetch(/api/settings/${group}).then(r => r.json());
}

export async function saveSettings(group: string, data: any): Promise<void> {
  await fetch(/api/settings/${group}, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
}

===== ./frontend/src/components/TarifSettings.tsx =====

import React, { useEffect } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Select,
  NumberInput,
  NumberInputField,
  Switch,
  SimpleGrid,
  Stat,
  StatLabel,
  StatNumber,
  Stack,
  Accordion,
  AccordionItem,
  AccordionButton,
  AccordionIcon,
  AccordionPanel
} from '@chakra-ui/react';
import { saveSettings } from '../api';

/* ───────────────────────── types & defaults ───────────────────────── */
export interface TarifInputUI {
  entgeltgruppe: string;
  stufe: string;
  wochenstunden: number;
  leistungszulage_pct: number;
  sonstige_zulage_pct: number;
  tzug_b_pct: number;
  urlaubsgeld_pct: number;
  transformationsgeld_pct: number;
  include_transformationsgeld: boolean;
  tzug_a_pct: number;
  weihnachtsgeld_pct_base: number;
  weihnachtsgeld_pct_max: number;
  betriebszugehoerigkeit_monate: number;
}

export const defaultTarifInput: TarifInputUI = {
  entgeltgruppe: 'EG 1',
  stufe: 'Grundentgelt',
  wochenstunden: 35,
  leistungszulage_pct: 0,
  sonstige_zulage_pct: 0,
  tzug_b_pct: 18.5,
  urlaubsgeld_pct: 72,
  transformationsgeld_pct: 18.4,
  include_transformationsgeld: true,
  tzug_a_pct: 27.5,
  weihnachtsgeld_pct_base: 25,
  weihnachtsgeld_pct_max: 55,
  betriebszugehoerigkeit_monate: 0
};

/* ------------------------------------------------------------------- */
const ERA_GROUPS: Record<string, string[]> = {
  EG1: ['Grundentgelt'],
  EG2: ['Grundentgelt'],
  EG3: ['Grundentgelt'],
  EG4: ['Grundentgelt'],
  EG5: ['Grundentgelt'],
  EG6: ['Grundentgelt'],
  EG7: ['Grundentgelt'],
  EG8: ['Grundentgelt'],
  EG9: ['Grundentgelt'],
  EG10: ['Grundentgelt'],
  EG11: ['Grundentgelt'],
  EG12: ['bis 36. Monat', 'nach 36. Monat'],
  EG13: ['bis 18. Monat', 'nach 18. Monat', 'nach 36. Monat'],
  EG14: ['bis 12. Monat', 'nach 12. Monat', 'nach 24. Monat', 'nach 36. Monat']
};

/* result type from API */
interface TarifResult {
  [k: string]: number;
}

interface Props {
  value: TarifInputUI;
  onChange: (v: TarifInputUI) => void;
}

const TarifSettings: React.FC<Props> = ({ value, onChange }) => {
  const stufen = ERA_GROUPS[value.entgeltgruppe.replace(' ', '')] ?? [
    'Grundentgelt'
  ];

  const set = <K extends keyof TarifInputUI>(k: K, v: TarifInputUI[K]) =>
    onChange({ ...value, [k]: v });

  const [result, setResult] = React.useState<TarifResult | null>(null);

  const num = (
    label: string,
    key: keyof TarifInputUI,
    step = 0.1,
    min?: number,
    max?: number
  ) => (
    <FormControl>
      <FormLabel>{label}</FormLabel>
      <NumberInput
        value={value[key] as number}
        onChange={(_, n) => set(key, Number.isNaN(n) ? 0 : n)}
        step={step}
        min={min}
        max={max}
        precision={2}
      >
        <NumberInputField />
      </NumberInput>
    </FormControl>
  );

  const calc = () =>
    fetch('/api/tarif/estimate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(value)
    })
      .then(r => r.json())
      .then(setResult);

  /* persist every change (App persists too, this is redundancy-safe) */
  useEffect(() => {
    saveSettings('tarif', value);
  }, [value]);

  return (
    <Stack spacing={4}>
      <SimpleGrid columns={[1, 2]} gap={4}>
        <FormControl>
          <FormLabel>Entgeltgruppe</FormLabel>
          <Select
            value={value.entgeltgruppe}
            onChange={e => set('entgeltgruppe', e.target.value)}
          >
            {Object.keys(ERA_GROUPS).map(g => (
              <option key={g}>{g.replace('EG', 'EG ')}</option>
            ))}
          </Select>
        </FormControl>

        <FormControl>
          <FormLabel>Stufe</FormLabel>
          <Select
            value={value.stufe}
            onChange={e => set('stufe', e.target.value)}
          >
            {stufen.map(s => (
              <option key={s}>{s}</option>
            ))}
          </Select>
        </FormControl>

        {num('Wochenstunden', 'wochenstunden', 1, 10, 40)}
        {num('Leistungszulage %', 'leistungszulage_pct')}
        {num('Sonstige Zulage %', 'sonstige_zulage_pct')}
      </SimpleGrid>

      <Accordion allowToggle>
        <AccordionItem border="none">
          <AccordionButton
            py={2}
            _expanded={{ fontWeight: 'bold' }}
            _hover={{ bg: 'gray.50' }}
          >
            Sonderzahlungen &nbsp;
            <AccordionIcon />
          </AccordionButton>
          <AccordionPanel pb={2}>
            <SimpleGrid columns={[1, 2]} gap={4}>
              {num('T-ZUG B %', 'tzug_b_pct')}
              {num('Urlaubsgeld %', 'urlaubsgeld_pct')}
              <FormControl display="flex" alignItems="center">
                <FormLabel mb={0}>Transformationsgeld aktiv</FormLabel>
                <Switch
                  isChecked={value.include_transformationsgeld}
                  onChange={e =>
                    set('include_transformationsgeld', e.target.checked)
                  }
                />
              </FormControl>
              {num('Transformationsgeld %', 'transformationsgeld_pct')}
              {num('T-ZUG A %', 'tzug_a_pct')}
              {num('Weihnachtsgeld Basis %', 'weihnachtsgeld_pct_base')}
              {num('Weihnachtsgeld Max %', 'weihnachtsgeld_pct_max')}
              {num(
                'Betriebszugehörigkeit (Monate)',
                'betriebszugehoerigkeit_monate',
                1,
                0,
                480
              )}
            </SimpleGrid>
          </AccordionPanel>
        </AccordionItem>
      </Accordion>

      <Button w="fit-content" onClick={calc}>
        Calculate
      </Button>

      {result && (
        <SimpleGrid columns={[1, 2]} gap={4}>
          {Object.entries(result).map(([k, v]) => (
            <Stat
              key={k}
              p={3}
              borderWidth="1px"
              rounded="md"
              bg="gray.50"
              _dark={{ bg: 'gray.700' }}
            >
              <StatLabel textTransform="capitalize">{k}</StatLabel>
              <StatNumber>
                {v.toLocaleString('de-DE', {
                  style: 'currency',
                  currency: 'EUR'
                })}
              </StatNumber>
            </Stat>
          ))}
        </SimpleGrid>
      )}
    </Stack>
  );
};

export default TarifSettings;

===== ./frontend/src/components/FinanceTable.tsx =====

import React, {
  useEffect,
  useState,
  useRef,
  forwardRef,
  useImperativeHandle
} from 'react';
import {
  Box,
  Button,
  HStack,
  IconButton,
  Input,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  NumberInput,
  NumberInputField,
  Table,
  Tbody,
  Td,
  Th,
  Thead,
  Tr,
  useColorModeValue
} from '@chakra-ui/react';
import { DeleteIcon, ChevronLeftIcon, ChevronRightIcon } from '@chakra-ui/icons';
import { FiCopy } from 'react-icons/fi';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
} from 'chart.js';

import { TarifInput } from '../App';
import {
  Cell,
  getFinance,
  saveCell,
  shiftRevision
} from '../api';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

/* ──────────────────────────────────────────────────────────────────── */
/*  Helper & types                                                     */
/* ──────────────────────────────────────────────────────────────────── */
export interface FinanceTableHandle {
  undo(): void;
  redo(): void;
}

interface Props {
  year: number;
  onYearChange: (y: number) => void;
  tarifInput: TarifInput;
}

/* Months */
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
  'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

interface Row {
  description: string;
  values: number[];
}

/* ──────────────────────────────────────────────────────────────────── */
const FinanceTable = forwardRef<FinanceTableHandle, Props>(
  ({ year, onYearChange, tarifInput }, ref) => {
    /* ── persistent state ─────────────────────────────────────────── */
    const [rows, setRows] = useState<Row[]>([
      { description: 'Income', values: Array(12).fill(0) }
    ]);
    const [revision, setRevision] = useState(0);
    const [showChart, setShowChart] = useState(false);

    /* ── debounced save ───────────────────────────────────────────── */
    const timer = useRef<NodeJS.Timeout>();

    const upsert = (r: number, c: number, v: number) => {
      setRows(prev => {
        const clone = [...prev];
        clone[r].values[c] = v;
        return clone;
      });
      clearTimeout(timer.current);
      timer.current = setTimeout(() => {
        saveCell({ year, row: r, col: c, value: v, revision });
      }, 250);
    };

    /* ── load from DB every time year / revision changes ──────────── */
    useEffect(() => {
      getFinance(year).then((cells) => {
        if (!cells.length) {
          setRows(prev => prev); // keep current
          return;
        }
        const maxRow = Math.max(...cells.map(c => c.row), 0);
        const r: Row[] = [];
        for (let i = 0; i <= maxRow; i++) {
          r.push({ description: i === 0 ? 'Income' : Item ${i}, values: Array(12).fill(0) });
        }
        cells.forEach(({ row, col, value }) => {
          if (!r[row]) r[row] = { description: Item ${row}, values: Array(12).fill(0) };
          r[row].values[col] = value;
        });
        setRows(r);
        setRevision(cells[0]?.revision ?? 0);
      });
    }, [year, revision]);

    /* ── carry-over from December of previous year ────────────────── */
    useEffect(() => {
      if (year <= 1970) return;
      getFinance(year - 1).then(prevCells => {
        const incomeDec =
          prevCells.find(c => c.row === 0 && c.col === 11)?.value ?? 0;
        const outDec = prevCells
          .filter(c => c.row !== 0 && c.col === 11)
          .reduce((s, c) => s + c.value, 0);
        const leftover = incomeDec - outDec;
        if (leftover !== 0) {
          upsert(rows.length - 1, 0, rows[rows.length - 1].values[0] + leftover);
        }
      });
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [year]);

    /* ── undo / redo exposed to parent ────────────────────────────── */
    useImperativeHandle(ref, () => ({
      undo() {
        shiftRevision(year, 'undo').then(setRevision);
      },
      redo() {
        shiftRevision(year, 'redo').then(setRevision);
      }
    }));

    /* ── monthly leftover for chart ───────────────────────────────── */
    const monthlyLeft: number[] = [];
    for (let i = 0; i < 12; i++) {
      const income = rows[0]?.values[i] ?? 0;
      const outcome = rows
        .slice(1)
        .reduce((sum, row) => sum + (row.values[i] || 0), 0);
      monthlyLeft[i] = (monthlyLeft[i - 1] || 0) + income - outcome;
    }

    const chartData = {
      labels: months,
      datasets: [
        {
          label: 'Leftover',
          data: monthlyLeft,
          borderColor: 'rgb(56,132,255)',
          backgroundColor: 'rgba(56,132,255,0.2)'
        }
      ]
    };

    /* ── styles ───────────────────────────────────────────────────── */
    const headerBg = useColorModeValue('gray.50', 'gray.800');
    const borderCol = useColorModeValue('gray.200', 'gray.600');

    /* ── edit modal state ─────────────────────────────────────────── */
    const [edit, setEdit] = useState<null | { row: number; col: number; val: number }>(null);

    /* ── helpers ──────────────────────────────────────────────────── */
    const deleteRow = (idx: number) =>
      setRows(prev => prev.filter((_, i) => i !== idx));

    const addRow = () =>
      setRows(prev => [...prev, { description: Item ${prev.length}, values: Array(12).fill(0) }]);

    /* ── render ───────────────────────────────────────────────────── */
    return (
      <Box w="full" h="full" overflow="auto">
        {/* controls */}
        <HStack mb={2} gap={2}>
          <IconButton
            aria-label="Prev year"
            icon={<ChevronLeftIcon />}
            size="sm"
            variant="outline"
            onClick={() => onYearChange(year - 1)}
          />
          <Box minW="70px" textAlign="center" fontWeight="bold">
            {year}
          </Box>
          <IconButton
            aria-label="Next year"
            icon={<ChevronRightIcon />}
            size="sm"
            variant="outline"
            onClick={() => onYearChange(year + 1)}
          />
          <Button size="sm" onClick={addRow}>
            Add row
          </Button>
          <Button size="sm" onClick={() => setShowChart(s => !s)}>
            {showChart ? 'Hide chart' : 'Show chart'}
          </Button>
        </HStack>

        {showChart && (
          <Box mb={4}>
            <Line data={chartData} />
          </Box>
        )}

        <Box overflowX="auto">
          <Table
            size="sm"
            variant="striped"
            w="full"
            sx={{
              'th, td': {
                borderRight: '1px solid',
                borderColor: borderCol
              },
              'th:last-child, td:last-child': { borderRight: 'none' },
              thead: {
                position: 'sticky',
                top: 0,
                zIndex: 1,
                bg: headerBg
              }
            }}
          >
            <Thead>
              <Tr>
                <Th>Description</Th>
                {months.map(m => (
                  <Th key={m}>
                    {m} {year}
                  </Th>
                ))}
                <Th w="40px" />
              </Tr>
            </Thead>
            <Tbody>
              {rows.map((row, rIdx) => (
                <Tr key={rIdx}>
                  <Td>
                    <Input
                      variant="flushed"
                      size="sm"
                      value={row.description}
                      onChange={e =>
                        setRows(prev => {
                          const clone = [...prev];
                          clone[rIdx].description = e.target.value;
                          return clone;
                        })
                      }
                    />
                  </Td>
                  {row.values.map((v, cIdx) => (
                    <Td
                      key={cIdx}
                      textAlign="right"
                      cursor="pointer"
                      onClick={() => setEdit({ row: rIdx, col: cIdx, val: v })}
                      _hover={{ bg: 'blue.50' }}
                    >
                      {v.toFixed(2)}
                    </Td>
                  ))}
                  <Td textAlign="center">
                    {rIdx !== 0 && (
                      <IconButton
                        aria-label="Delete row"
                        icon={<DeleteIcon />}
                        size="xs"
                        variant="ghost"
                        colorScheme="red"
                        onClick={() => deleteRow(rIdx)}
                      />
                    )}
                  </Td>
                </Tr>
              ))}
              <Tr fontWeight="bold">
                <Td>Leftover</Td>
                {monthlyLeft.map((v, i) => (
                  <Td key={i} textAlign="right">
                    {v.toFixed(2)}
                  </Td>
                ))}
                <Td />
              </Tr>
            </Tbody>
          </Table>
        </Box>

        {/* cell edit modal */}
        <Modal isOpen={!!edit} onClose={() => setEdit(null)} isCentered>
          <ModalOverlay />
          {edit && (
            <ModalContent>
              <ModalHeader>Edit value</ModalHeader>
              <ModalCloseButton />
              <ModalBody>
                <HStack>
                  <NumberInput
                    value={edit.val}
                    onChange={(_, n) => setEdit(e => (e ? { ...e, val: n } : e))}
                    precision={2}
                    step={10}
                  >
                    <NumberInputField autoFocus />
                  </NumberInput>
                  <IconButton
                    aria-label="Copy to row"
                    icon={<FiCopy />}
                    title="Fill entire row"
                    onClick={() => {
                      setRows(prev => {
                        const clone = [...prev];
                        clone[edit.row].values = Array(12).fill(edit.val);
                        return clone;
                      });
                      for (let m = 0; m < 12; m++)
                        saveCell({
                          year,
                          row: edit.row,
                          col: m,
                          value: edit.val,
                          revision
                        });
                      setEdit(null);
                    }}
                  />
                  <Button
                    ml="auto"
                    onClick={() => {
                      upsert(edit.row, edit.col, edit.val);
                      setEdit(null);
                    }}
                  >
                    OK
                  </Button>
                </HStack>
              </ModalBody>
            </ModalContent>
          )}
        </Modal>
      </Box>
    );
  }
);

export default FinanceTable;

===== ./frontend/src/components/PayrollSettings.tsx =====

import React, { useEffect } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  NumberInput,
  NumberInputField,
  Select,
  SimpleGrid,
  Stat,
  StatLabel,
  StatNumber,
  Stack,
  Switch
} from '@chakra-ui/react';
import { saveSettings } from '../api';

/* ───────────── UI type + defaults ───────────── */
export interface PayrollInputUI {
  gross: number;
  period: 'monthly' | 'yearly';
  tax_class: number;
  married: boolean;
  federal_state: string;
  church: boolean;
  childless: boolean;
  additional_kv: number;
}

export const defaultPayrollInput: PayrollInputUI = {
  gross: 4000,
  period: 'monthly',
  tax_class: 1,
  married: false,
  federal_state: 'NW',
  church: false,
  childless: true,
  additional_kv: 0.025
};

/* ───────────── component ───────────── */
interface PayrollResult {
  [k: string]: number;
}

interface Props {
  value: PayrollInputUI;
  onChange: (v: PayrollInputUI) => void;
}

const PayrollSettings: React.FC<Props> = ({ value, onChange }) => {
  const [result, setResult] = React.useState<PayrollResult | null>(null);

  const set = <K extends keyof PayrollInputUI>(k: K, v: PayrollInputUI[K]) =>
    onChange({ ...value, [k]: v });

  const calc = () =>
    fetch('/api/payroll/gross-to-net', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(value)
    })
      .then(r => r.json())
      .then(setResult);

  /* persist */
  useEffect(() => {
    saveSettings('payroll', value);
  }, [value]);

  const num = (
    label: string,
    key: keyof PayrollInputUI,
    step = 1,
    min?: number,
    max?: number
  ) => (
    <FormControl>
      <FormLabel>{label}</FormLabel>
      <NumberInput
        value={value[key] as number}
        onChange={(_, n) => set(key, Number.isNaN(n) ? 0 : n)}
        step={step}
        min={min}
        max={max}
        precision={2}
      >
        <NumberInputField />
      </NumberInput>
    </FormControl>
  );

  return (
    <Stack spacing={4}>
      <SimpleGrid columns={[1, 2]} gap={4}>
        {num('Gross', 'gross', 50, 0)}
        <FormControl>
          <FormLabel>Period</FormLabel>
          <Select
            value={value.period}
            onChange={e => set('period', e.target.value as any)}
          >
            <option value="monthly">monthly</option>
            <option value="yearly">yearly</option>
          </Select>
        </FormControl>

        {num('Tax class', 'tax_class', 1, 1, 6)}
        <FormControl>
          <FormLabel>Married</FormLabel>
          <Switch
            isChecked={value.married}
            onChange={e => set('married', e.target.checked)}
          />
        </FormControl>

        <FormControl>
          <FormLabel>Federal state</FormLabel>
          <Select
            value={value.federal_state}
            onChange={e => set('federal_state', e.target.value)}
          >
            {[
              'BW',
              'BY',
              'NW',
              'NI',
              'HB',
              'HH',
              'HE',
              'RP',
              'SL',
              'SH',
              'MV',
              'SN',
              'ST',
              'BB',
              'BE',
              'TH'
            ].map(s => (
              <option key={s}>{s}</option>
            ))}
          </Select>
        </FormControl>

        <FormControl>
          <FormLabel>Church tax</FormLabel>
          <Switch
            isChecked={value.church}
            onChange={e => set('church', e.target.checked)}
          />
        </FormControl>
        <FormControl>
          <FormLabel>Childless</FormLabel>
          <Switch
            isChecked={value.childless}
            onChange={e => set('childless', e.target.checked)}
          />
        </FormControl>

        {num('Additional KV %', 'additional_kv', 0.001, 0, 0.05)}
      </SimpleGrid>

      <Button w="fit-content" onClick={calc}>
        Calculate
      </Button>

      {result && (
        <>
          <Box fontWeight="bold">Breakdown</Box>
          <SimpleGrid columns={[1, 2, 3]} gap={4}>
            {Object.entries(result).map(([k, v]) => (
              <Stat
                key={k}
                p={3}
                borderWidth="1px"
                rounded="md"
                bg="gray.50"
                _dark={{ bg: 'gray.700' }}
              >
                <StatLabel textTransform="capitalize">{k}</StatLabel>
                <StatNumber>
                  {v.toLocaleString('de-DE', {
                    style: 'currency',
                    currency: 'EUR'
                  })}
                </StatNumber>
              </Stat>
            ))}
          </SimpleGrid>
        </>
      )}
    </Stack>
  );
};

export default PayrollSettings;

===== ./backend/app/auth.py =====

from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional

SECRET_KEY = "secret"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

===== ./backend/app/models.py =====

from datetime import datetime
from typing import Optional, Dict, Any

from sqlmodel import SQLModel, Field
from sqlalchemy import Column, JSON as SA_JSON


class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(unique=True, index=True)
    hashed_password: str
    is_active: bool = True
    created_at: datetime = Field(default_factory=datetime.utcnow)


# ─────────────────────────────────────────────────────────────────────────────
#  Finance-table cells (one cell per month / row / col / year)
# ─────────────────────────────────────────────────────────────────────────────
class FinanceCell(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: Optional[int] = Field(default=None, foreign_key="user.id")
    year: int = Field(index=True)
    row: int
    col: int
    value: float
    revision: int = 0                     # 0–10 ring buffer for undo/redo
    ts: datetime = Field(default_factory=datetime.utcnow)


# ─────────────────────────────────────────────────────────────────────────────
#  Persisted settings (latest snapshot is loaded as defaults)
# ─────────────────────────────────────────────────────────────────────────────
class Setting(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: Optional[int] = Field(default=None, foreign_key="user.id")
    group: str = Field(index=True)        # "tarif" | "payroll"
    # JSON column needs explicit SQLAlchemy Column wrapper ⬇
    data: Dict[str, Any] = Field(sa_column=Column(SA_JSON))
    ts: datetime = Field(default_factory=datetime.utcnow)

===== ./backend/app/database.py =====

"""
Centralised DB helpers.

▪ we map **SQLModel.Session** into a session-maker so the objects returned
  by SessionLocal() expose the convenient .exec() convenience wrapper.
▪ init_db() is called from *main.py* during application start-up to make
  sure the tables are present (simple auto-migration for dev / demo use-cases).
"""
from __future__ import annotations

import os

from sqlmodel import SQLModel, Session, create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://user:password@db:5432/finance",
)

# set SQL_ECHO=1 in the environment if you want to see all SQL in the logs
engine = create_engine(DATABASE_URL, echo=os.getenv("SQL_ECHO") == "1")

# IMPORTANT: class_=Session → each instance is *sqlmodel.Session* (has .exec)
SessionLocal = sessionmaker(bind=engine, class_=Session, expire_on_commit=False)


def init_db() -> None:
    """Create all tables that are still missing."""
    SQLModel.metadata.create_all(engine)

===== ./backend/app/__init__.py =====


===== ./backend/app/payroll.py =====

"""Payroll calculator for German net salary estimation (2025)."""
from dataclasses import dataclass, asdict
from typing import Dict, Tuple

# ---------------- 1  Konstanten ----------------
BASIC_ALLOWANCE = 12_096
ZONE1_END, ZONE2_END, ZONE3_END = 17_443, 68_480, 277_825

SOLI_FREE_SINGLE, SOLI_FREE_MARRIED, SOLI_RATE = 19_950, 39_900, .055

KIST_BY_STATE = {"BY": .09, "BW": .09, **{k: .08 for k in
    "NW NI HB HH HE RP SL SH MV SN ST BB BE TH".split()}}

KV_GENERAL, KV_AVG_ADD = .146, .025
PV_BASE, PV_CHILDLESS_SURCH = .036, .006
RV_RATE, AV_RATE = .186, .026

BBG_KV_PV, BBG_RV_AV = 5_512.50, 8_050.00

WK_PAUSCHALE, SONDERAUSG_PAUS, VSP_MAX_RATE = 1_230, 36, .20

# --------------- 2  Steuerfunktionen ----------
def income_tax(zve: float) -> float:
    if zve <= BASIC_ALLOWANCE:
        return 0.0
    if zve <= ZONE1_END:
        y = (zve - BASIC_ALLOWANCE) / 10_000
        return (932.3 * y + 1_400) * y
    if zve <= ZONE2_END:
        z = (zve - ZONE1_END) / 10_000
        return (176.64 * z + 2_397) * z + 1_015.13
    if zve <= ZONE3_END:
        return 0.42 * zve - 10_911.92
    return 0.45 * zve - 19_246.67

def soli(tax: float, married: bool=False) -> float:
    free = SOLI_FREE_MARRIED if married else SOLI_FREE_SINGLE
    if tax <= free:
        return 0.0
    diff = tax - free
    return min(0.19945 * diff, SOLI_RATE * tax) if diff < 1_000 else SOLI_RATE * tax

# --------------- 3  Datenklassen -------------
@dataclass
class PayrollInputData:
    gross: float
    period: str = "monthly"          # 'monthly' | 'yearly'
    tax_class: int = 1
    married: bool = False
    federal_state: str = "NW"
    church: bool = False
    childless: bool = True
    additional_kv: float = KV_AVG_ADD

@dataclass
class PayrollResultData:
    net: float
    income_tax: float
    solidarity: float
    church_tax: float
    health_employee: float
    health_employer: float
    care_employee: float
    care_employer: float
    pension_employee: float
    pension_employer: float
    unemployment_employee: float
    unemployment_employer: float
    def asdict(self) -> Dict:
        return asdict(self)

# --------------- 4  Hauptfunktion -----------
def gross_to_net(data: PayrollInputData) -> PayrollResultData:
    m_gross = data.gross if data.period == "monthly" else data.gross / 12
    a_gross = m_gross * 12

    # Sozialversicherung
    kv_rate = KV_GENERAL + data.additional_kv
    kv_emp = kv_ag = min(m_gross, BBG_KV_PV) * kv_rate / 2

    pv_emp = pv_ag = min(m_gross, BBG_KV_PV) * PV_BASE / 2
    if data.childless:                              # Zuschlag mit BBG-Deckel!
        pv_emp += min(m_gross, BBG_KV_PV) * PV_CHILDLESS_SURCH

    rv_emp = rv_ag = min(m_gross, BBG_RV_AV) * RV_RATE / 2
    av_emp = av_ag = min(m_gross, BBG_RV_AV) * AV_RATE / 2

    sv_emp_annual = 12 * (kv_emp + pv_emp + rv_emp + av_emp)
    vsp = min(sv_emp_annual, VSP_MAX_RATE * a_gross)

    # Steuer
    zvE = a_gross - vsp - WK_PAUSCHALE - SONDERAUSG_PAUS
    tax_y = income_tax(max(0, zvE))
    if   data.tax_class == 3: tax_y = 2 * income_tax(zvE / 2)
    elif data.tax_class == 5: tax_y *= 1.20
    elif data.tax_class == 6: tax_y *= 1.30

    tax_m  = tax_y / 12
    soli_m = soli(tax_y, data.married) / 12
    kist_m = tax_m * KIST_BY_STATE[data.federal_state] if data.church else 0.0

    deductions = tax_m + soli_m + kist_m + kv_emp + pv_emp + rv_emp + av_emp
    net_m = m_gross - deductions
    net   = net_m if data.period == "monthly" else net_m * 12

    return PayrollResultData(
        net=round(net, 2),
        income_tax=round(tax_m if data.period == "monthly" else tax_y, 2),
        solidarity=round(soli_m if data.period == "monthly" else soli_m * 12, 2),
        church_tax=round(kist_m if data.period == "monthly" else kist_m * 12, 2),
        health_employee=round(kv_emp, 2),
        health_employer=round(kv_ag, 2),
        care_employee=round(pv_emp, 2),
        care_employer=round(pv_ag, 2),
        pension_employee=round(rv_emp, 2),
        pension_employer=round(rv_ag, 2),
        unemployment_employee=round(av_emp, 2),
        unemployment_employer=round(av_ag, 2),
    )

def net_to_gross(target_net: float, **kwargs) -> Tuple[float, PayrollResultData]:
    lo, hi = 0.0, target_net * 3
    result = None
    for _ in range(25):
        mid = (lo + hi) / 2
        result = gross_to_net(PayrollInputData(gross=mid, **kwargs))
        hi, lo = (mid, lo) if result.net > target_net else (hi, mid)
    return round(hi, 2), result

===== ./backend/app/api.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

from .database import SessionLocal
from . import schemas, models
from .payroll import gross_to_net, PayrollInputData
from .tarif import berechne_nrw_2025, TarifInputData, get_monthly_breakdown

router = APIRouter()

# ───────────────────────── helpers ─────────────────────────
def db():
    with SessionLocal() as session:
        yield session


# ───────────────────────── payroll / tarif ─────────────────────────
@router.post("/payroll/gross-to-net", response_model=schemas.PayrollResult)
def payroll_g2n(data: schemas.PayrollInput):
    return gross_to_net(PayrollInputData(**data.dict())).asdict()


@router.post("/tarif/estimate", response_model=schemas.TarifResult)
def tarif_estimate(data: schemas.TarifInput):
    return berechne_nrw_2025(TarifInputData(**data.dict())).asdict()


@router.post("/tarif/breakdown", response_model=list[schemas.MonthlyBreakdown])
def tarif_breakdown(data: schemas.TarifInput):
    return get_monthly_breakdown(TarifInputData(**data.dict()))


# ───────────────────────── finance-table persistence ────────────────────────
@router.get("/finance/{year}", response_model=list[schemas.Cell])
def finance_year(year: int, s: Session = Depends(db)):
    """
    Return the latest *revision* snapshot for the requested year.
    """
    latest_rev = (
        s.exec(
            select(models.FinanceCell.revision)
            .where(models.FinanceCell.year == year)
            .order_by(models.FinanceCell.revision.desc())
            .limit(1)
        ).first()
        or 0
    )
    stmt = select(models.FinanceCell).where(
        models.FinanceCell.year == year, models.FinanceCell.revision == latest_rev
    )
    return s.exec(stmt).all()


@router.post("/finance/cell", response_model=schemas.Cell)
def save_cell(cell: schemas.Cell, s: Session = Depends(db)):
    """
    Up-sert a single table cell.
    All edits are stored inside the *current* revision that the client passes
    back – the UI keeps track of the revision id it is working on.
    """
    query = select(models.FinanceCell).where(
        models.FinanceCell.year == cell.year,
        models.FinanceCell.row == cell.row,
        models.FinanceCell.col == cell.col,
        models.FinanceCell.revision == cell.revision,
    )
    db_cell = s.exec(query).first()
    if db_cell:
        db_cell.value = cell.value
    else:
        db_cell = models.FinanceCell(**cell.dict())
        s.add(db_cell)

    s.commit()
    s.refresh(db_cell)
    return db_cell


@router.post("/finance/revision/{year}/{direction}", response_model=int)
def shift_revision(year: int, direction: str, s: Session = Depends(db)):
    """
    Create a new revision snapshot and return its id.

    * **undo**  → go one step back (min 0)
    * **redo**  → go one step forward (max 10)
    """
    if direction not in {"undo", "redo"}:
        raise HTTPException(400, "direction must be 'undo' or 'redo'")

    latest = (
        s.exec(
            select(models.FinanceCell.revision)
            .where(models.FinanceCell.year == year)
            .order_by(models.FinanceCell.revision.desc())
            .limit(1)
        ).first()
        or 0
    )

    target = max(0, latest - 1) if direction == "undo" else min(latest + 1, 10)
    if target == latest:
        return latest  # nothing to do

    # if the target revision already exists we just return it
    exists = s.exec(
        select(models.FinanceCell.id).where(
            models.FinanceCell.year == year, models.FinanceCell.revision == target
        )
    ).first()
    if exists:
        return target

    # otherwise copy snapshot from the latest revision
    snapshot = s.exec(
        select(models.FinanceCell).where(
            models.FinanceCell.year == year, models.FinanceCell.revision == latest
        )
    ).all()
    for c in snapshot:
        s.add(
            models.FinanceCell(
                year=c.year,
                row=c.row,
                col=c.col,
                value=c.value,
                revision=target,
            )
        )
    s.commit()
    return target


# ───────────────────────── user settings persistence ────────────────────────
@router.get("/settings/{group}", response_model=schemas.Settings)
def get_settings(group: str, s: Session = Depends(db)):
    rec = s.exec(
        select(models.Setting)
        .where(models.Setting.group == group)
        .order_by(models.Setting.ts.desc())
    ).first()
    return rec.data if rec else {}


@router.post("/settings/{group}", response_model=schemas.Settings)
def save_settings(group: str, payload: dict, s: Session = Depends(db)):
    s.add(models.Setting(group=group, data=payload))
    s.commit()
    return payload

===== ./backend/app/schemas.py =====

from typing import Dict, Any, List
from pydantic import BaseModel


# ───────────── existing payroll / tarif models unchanged ────────────────
class PayrollInput(BaseModel):
    gross: float
    period: str = "monthly"
    tax_class: int = 1
    married: bool = False
    federal_state: str = "NW"
    church: bool = False
    childless: bool = True
    additional_kv: float = 0.025


class PayrollResult(BaseModel):
    net: float
    income_tax: float
    solidarity: float
    church_tax: float
    health_employee: float
    health_employer: float
    care_employee: float
    care_employer: float
    pension_employee: float
    pension_employer: float
    unemployment_employee: float
    unemployment_employer: float


class TarifInput(BaseModel):
    entgeltgruppe: str
    stufe: str
    wochenstunden: float = 35
    leistungszulage_pct: float = 0.0
    sonstige_zulage_pct: float = 0.0
    tzug_b_pct: float = 18.5
    urlaubsgeld_pct: float = 72.0
    transformationsgeld_pct: float = 18.4
    tzug_a_pct: float = 27.5
    weihnachtsgeld_pct_base: float = 25.0
    weihnachtsgeld_pct_max: float = 55.0
    betriebszugehoerigkeit_monate: int = 0
    include_transformationsgeld: bool = True


class TarifResult(BaseModel):
    monatsgrund: float
    zulagen: float
    monatsgesamt: float
    tzug_b: float
    urlaubsgeld: float
    transformationsgeld: float
    tzug_a: float
    weihnachtsgeld: float
    jahresentgelt: float


class MonthlyBreakdown(BaseModel):
    Monat: str
    Brutto: float
    Bestandteile: str


# ───────────── new DTOs for persistence / history ───────────────────────
class Cell(BaseModel):
    year: int
    row: int
    col: int
    value: float
    revision: int = 0


Settings = Dict[str, Any]        #  alias for JSON settings blobs

===== ./backend/app/tarif.py =====

"""IG Metall NRW 2025 tariff calculator."""
from dataclasses import dataclass, asdict
from typing import Dict, List, Any

TARIF_NRW_2025: Dict[str, Dict[str, float]] = {
    "EG 1":  {"Grundentgelt": 2_705.00},
    "EG 2":  {"Grundentgelt": 2_738.00},
    "EG 3":  {"Grundentgelt": 2_769.50},
    "EG 4":  {"Grundentgelt": 2_812.50},
    "EG 5":  {"Grundentgelt": 2_871.50},
    "EG 6":  {"Grundentgelt": 2_946.00},
    "EG 7":  {"Grundentgelt": 3_038.00},
    "EG 8":  {"Grundentgelt": 3_196.00},
    "EG 9":  {"Grundentgelt": 3_454.00},
    "EG 10": {"Grundentgelt": 3_796.50},
    "EG 11": {"Grundentgelt": 4_257.00},
    "EG 12": {"bis 36. Monat": 4_387.00, "nach 36. Monat": 4_872.00},
    "EG 13": {
        "bis 18. Monat": 4_902.00,
        "nach 18. Monat": 5_190.50,
        "nach 36. Monat": 5_766.50,
    },
    "EG 14": {
        "bis 12. Monat": 5_568.50,
        "nach 12. Monat": 5_917.00,
        "nach 24. Monat": 6_265.50,
        "nach 36. Monat": 6_962.50,
    },
}

TZUG_B_REF = TARIF_NRW_2025["EG 8"]["Grundentgelt"]

STANDARD_HOURS = 35

@dataclass
class TarifInputData:
    entgeltgruppe: str
    stufe: str
    wochenstunden: float = 35
    leistungszulage_pct: float = 0.0
    sonstige_zulage_pct: float = 0.0
    tzug_b_pct: float = 18.5
    urlaubsgeld_pct: float = 72.0
    transformationsgeld_pct: float = 18.4
    tzug_a_pct: float = 27.5
    weihnachtsgeld_pct_base: float = 25.0
    weihnachtsgeld_pct_max: float = 55.0
    betriebszugehoerigkeit_monate: int = 0
    include_transformationsgeld: bool = True

@dataclass
class TarifResultData:
    monatsgrund: float
    zulagen: float
    monatsgesamt: float
    tzug_b: float
    urlaubsgeld: float
    transformationsgeld: float
    tzug_a: float
    weihnachtsgeld: float
    jahresentgelt: float
    def asdict(self):
        return asdict(self)


def berechne_nrw_2025(inp: TarifInputData) -> TarifResultData:
    eg_data = TARIF_NRW_2025.get(inp.entgeltgruppe)
    if not eg_data:
        raise ValueError("Unbekannte Entgeltgruppe.")
    if inp.stufe not in eg_data:
        raise ValueError(
            f"Stufe '{inp.stufe}' in {inp.entgeltgruppe} nicht hinterlegt."
        )
    grund_tab = eg_data[inp.stufe]

    faktor = inp.wochenstunden / STANDARD_HOURS
    grund_zeit = grund_tab * faktor

    lz = grund_zeit * inp.leistungszulage_pct / 100
    sonst = grund_zeit * inp.sonstige_zulage_pct / 100
    monatsgesamt = grund_zeit + lz + sonst

    tzug_b = TZUG_B_REF * inp.tzug_b_pct / 100 * faktor
    urlaubsgeld = monatsgesamt * inp.urlaubsgeld_pct / 100
    transformationsgeld = (
        monatsgesamt * inp.transformationsgeld_pct / 100
        if inp.include_transformationsgeld else 0.0
    )
    tzug_a = monatsgesamt * inp.tzug_a_pct / 100

    wg_pct = (
        inp.weihnachtsgeld_pct_max if inp.betriebszugehoerigkeit_monate >= 36
        else inp.weihnachtsgeld_pct_base
    )
    weihnachtsgeld = monatsgesamt * wg_pct / 100

    jahresentgelt = (
        monatsgesamt * 12 +
        tzug_b + urlaubsgeld + transformationsgeld + tzug_a + weihnachtsgeld
    )

    return TarifResultData(
        monatsgrund=round(grund_zeit, 2),
        zulagen=round(lz + sonst, 2),
        monatsgesamt=round(monatsgesamt, 2),
        tzug_b=round(tzug_b, 2),
        urlaubsgeld=round(urlaubsgeld, 2),
        transformationsgeld=round(transformationsgeld, 2),
        tzug_a=round(tzug_a, 2),
        weihnachtsgeld=round(weihnachtsgeld, 2),
        jahresentgelt=round(jahresentgelt, 2),
    )


def get_monthly_breakdown(inp: TarifInputData) -> List[Dict[str, Any]]:
    res = berechne_nrw_2025(inp)
    base = res.monatsgesamt

    def record(month: str, gross: float, components: List[str]):
        return {
            "Monat": month,
            "Brutto": round(gross, 2),
            "Bestandteile": ", ".join(components)
        }

    months: List[Dict[str, Any]] = []
    months.append(record("Januar", base, ["Grund-/Zulagen"]))
    months.append(record("Februar", base + res.tzug_b, ["Grund-/Zulagen", "T-ZUG B"]))
    months.append(record("März", base, ["Grund-/Zulagen"]))
    months.append(record("April", base, ["Grund-/Zulagen"]))
    months.append(record("Mai", base, ["Grund-/Zulagen"]))
    months.append(record("Juni", base + res.urlaubsgeld, ["Grund-/Zulagen", "Urlaubsgeld"]))
    comps = ["Grund-/Zulagen", "T-ZUG A"]
    juli_extra = res.tzug_a + res.transformationsgeld
    if res.transformationsgeld:
        comps.append("Transformationsgeld")
    months.append(record("Juli", base + juli_extra, comps))
    months.append(record("August", base, ["Grund-/Zulagen"]))
    months.append(record("September", base, ["Grund-/Zulagen"]))
    months.append(record("Oktober", base, ["Grund-/Zulagen"]))
    months.append(record("November", base + res.weihnachtsgeld, ["Grund-/Zulagen", "Weihnachtsgeld"]))
    months.append(record("Dezember", base, ["Grund-/Zulagen"]))
    return months

===== ./backend/app/main.py =====

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from .api import router
from .database import init_db

# ---------------------------------------------------------------------------
# initialise DB schema once at process start-up
# ---------------------------------------------------------------------------
init_db()

app = FastAPI(title="Finance Suite API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(router, prefix="/api")


@app.get("/")
def read_root():
    return {"message": "Finance Suite API"}

===== ./backend/requirements.txt =====

fastapi
uvicorn
sqlmodel
pydantic
passlib[bcrypt]
jose
psycopg2-binary
pytest

===== ./backend/Dockerfile =====

FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
COPY app ./app
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8878"]

===== ./backend/tests/test_tarif.py =====

from backend.app.tarif import berechne_nrw_2025, TarifInputData


def test_tarif_basic():
    inp = TarifInputData(entgeltgruppe="EG 1", stufe="Grundentgelt")
    res = berechne_nrw_2025(inp)
    assert res.monatsgesamt > 0

===== ./backend/tests/test_payroll.py =====

from backend.app.payroll import gross_to_net, PayrollInputData


def test_gross_to_net_basic():
    inp = PayrollInputData(gross=4000)
    res = gross_to_net(inp)
    assert res.net > 0

===== ./backend/__init__.py =====



===== ./README.md =====

# Finance Suite

This is a minimal full-stack example using **FastAPI**, **SQLModel**, **PostgreSQL**, **React** (with TypeScript, Vite and Chakra UI) and **Docker Compose**. It includes utilities to estimate German net salary and IG Metall tariff incomes.

## Development

Requirements: Docker and Docker Compose.

Start the stack for development:

bash
docker compose up --build


The API will be available at http://localhost:8878 and the frontend via Traefik at http://localhost:8877.

Run tests locally with:

bash
pip install -r backend/requirements.txt
python -m pytest backend/tests -q


===== ./docker-compose.yml =====

version: '3.9'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: finance
    volumes:
      - db-data:/var/lib/postgresql/data
    restart: always

  backend:
    build: ./backend
    volumes:
      - ./backend:/app
    environment:
      DATABASE_URL: postgresql://user:password@db:5432/finance
    ports:
      - "8878:8878"
    labels:
      - "traefik.http.routers.backend.rule=PathPrefix(/api)"
      - "traefik.http.services.backend.loadbalancer.server.port=8878"
    depends_on:
      - db

  frontend:
    build: ./frontend
    depends_on:
      - backend
    labels:
      - "traefik.http.routers.frontend.rule=PathPrefix(/)"
      - "traefik.http.services.frontend.loadbalancer.server.port=80"
      - "traefik.http.routers.frontend.entrypoints=web"

  traefik:
    image: traefik:v2.10
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--entrypoints.web.address=:8877"
    ports:
      - "8877:8877"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      - frontend

volumes:
  db-data:
